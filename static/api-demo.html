<!DOCTYPE html>
<html>
	<head>
		<title>Vail API Demo</title>
		<style>
body {
	font-family: Arimo, Arial, monospace;
}

section {
	border: 1px solid black;
	margin: 1em;
}

p {
	max-width: 40em;
}

.log {
	max-height: 10em;
	overflow: scroll;
}

#decodedText {
	margin-top: 20px;
	font-size: 1.2em;
	font-weight: bold;
}

#wpmDisplay {
	margin-top: 10px;
	font-size: 1.1em;
	font-weight: bold;
}
		</style>
		<script type="module">
import { decodeMorse, morseToText, updateDurations, clearAccumulatedDurations, getAccumulatedDurations, getWpm, appendToDecodedString, getDecodedString } from './scripts/decoder.mjs';

let characterTimeoutHandle = null;
let wordTimeoutHandle = null;
const WORD_TIMEOUT = 7;

const Millisecond = 1;
const Second = Millisecond * 1000;

/** Vail server connection.
 *
 * This opens a websocket to the given repeater on vail.woozle.org,
 * and dispatches events to itself. Use .addEventListener to set up
 * event handlers as you desire.
 *
 * Events:
 *    clients: the number of connected clients has changed
 *    message: a message was recieved
 *    sound: your application should start making a sound
 *    nosound: your application should stop making a sound
 *
 * Multiple sequential sound events may be dispatched before a nosound event is.
 * This indicates "cross-talk": two people are sending to the repeater at the
 * same time.
 *
 * Class variables you may enjoy:
 *
 *   delay: rx delay to add to incoming messages, higher-latency networks will need a larger value
 *   transmitters: how many clients are sounding
 *   reconnect: if true, will try to maintain a connection to the server
 *   reconnectDelay: how long to wait between disconnection and reconnect attempt
 *   clients: how many connected clients the repeater last reported
 *   offset: clock skew between us and the repeater
 */
class Vail extends EventTarget {
	constructor(repeater) {
		super()

		/** URL to our WebSocket */
		this.url = new URL("ws://localhost:8080/chat")
		this.url.searchParams.set("repeater", repeater)

		/** Delay to add */
		this.delay = 4 * Second

		/** How many things are making sound right now. 0 == be quiet */
		this.transmitters = 0

		/** Attempt to reconnect if the websocket closes */
		this.reconnect = true

		/** How long to wait before trying to reconnect */
		this.reconnectDelay = 3 * Second

		this.reopen()
	}

	/** Close the web socket and stop trying to reconnect */
	close() {
		this.reconnect = false
		if (!this.socket) {
			return
		}
		this.socket.close()
	}

	reopen() {
		/** Number of clients connected */
		this.clients = 0

		/** Timestamp offset for incoming messages */
		this.offset = 0

		/** Our current websocket */
		this.socket = new WebSocket(this.url, ["json.vail.woozle.org"])
		this.socket.addEventListener("close", event => {
			addTimeout(() => this.reopen(), this.reconnectDelay)
		})
		this.socket.addEventListener("message", event => {
			this.message(event)
		})
	}

	message(event) {
		let message = JSON.parse(event.data)
		this.dispatchEvent(new CustomEvent("message", {detail: {message}}))
		if (message.Clients != this.clients) {
			this.clients = message.Clients
			this.dispatchEvent(new CustomEvent("clients", {detail: {clients: this.clients}}))
		}
		if (message.Duration.length == 0) {
			this.offset = Date.now() - message.Timestamp
			return
		}

		// Defer dispatching sound events
		let now = Date.now()
		let when = message.Timestamp + this.offset + this.delay
		let tx = true
		let detail = {}
		for (let duration of message.Duration) {
			let delay = when - now
			if (tx && (delay >= 0)) {
				setTimeout(() => this.sound(true, {when, duration}), delay)
				setTimeout(() => this.sound(false, {when: when+duration, duration}), delay + duration)
			}
			when += duration
			tx = !tx
		}
	}

	/** Dispatch a sound event.
	 *
	 * This keeps an internal count of how many things are making sound at once.
	 * When that count reaches 0, a "nosound" event is dispatched.
	 *
	 * @param {bool} tx True to make sound, false to stop making sound.
	 * @param {Object} detail CustomEvent detail
	 */
	sound(tx, detail) {
		if (tx) {
			this.transmitters++
		} else {
			this.transmitters--
		}
		detail.transmitters = this.transmitters

		if (this.transmitters > 0) {
			this.dispatchEvent(new CustomEvent("sound", {detail}))
		} else {
			this.dispatchEvent(new CustomEvent("nosound", {detail}))
		}
	}
}

/** Log an event's detail */
function log(selector, event) {
	let section = document.querySelector(selector)
	let log = section.querySelector(".log")
	let line = log.appendChild(document.createElement("div"))
	line.textContent = event.type + ": " + JSON.stringify(event.detail)
	line.scrollIntoView()
}

/** Update the displayed number of clients. */
function clients(event) {
	let clients = document.querySelector("#nclients")
	clients.textContent = event.target.clients
}

/** Handle the sound events for decoding Morse code. */
function sound(event) {
	const { when, duration, transmitters } = event.detail;
	if (transmitters > 0) {
		// Update durations and get WPM
		let currentWpm = updateDurations(duration, when);

		// Update WPM display
		let wpmElement = document.getElementById("wpmDisplay");
		wpmElement.textContent = `Guessed WPM: ${currentWpm}`;

		// Set a timeout to determine end of character
		const unitTime = 60 / (50 * currentWpm) * 1000; // Calculate unit time based on WPM
		const timeoutDuration = 3 * unitTime * 1.5; // Add padding to the timeout duration
		if (characterTimeoutHandle) {
			clearTimeout(characterTimeoutHandle);
		}
		characterTimeoutHandle = setTimeout(() => {
			// Decode the accumulated durations
			const morseCode = decodeMorse(getAccumulatedDurations(), unitTime);
			const decodedText = morseToText(morseCode);

			// Display the decoded character in a separate area
			appendToDecodedString(decodedText);
			let decodedTextElement = document.getElementById("decodedText");
			decodedTextElement.textContent = `Decoded Message: ${getDecodedString()}`;

			// Clear accumulated data
			clearAccumulatedDurations();
		}, timeoutDuration);

		// Set a timeout to determine end of word
		const wordTimeoutDuration = WORD_TIMEOUT * unitTime * 1.5; // Add padding to the word timeout duration
		if (wordTimeoutHandle) {
			clearTimeout(wordTimeoutHandle);
		}
		wordTimeoutHandle = setTimeout(() => {
			// Insert a space if the last character was not already a space
			if (getDecodedString().slice(-1) !== " ") {
				appendToDecodedString(" ");
				let decodedTextElement = document.getElementById("decodedText");
				decodedTextElement.textContent = `Decoded Message: ${getDecodedString()}`;
			}
		}, wordTimeoutDuration);
	}
}

let vail = new Vail("demo") // Connect to the "demo" repeater
vail.addEventListener("message", event => log("#messages", event))
vail.addEventListener("clients", event => log("#clients", event))
vail.addEventListener("sound", event => log("#sounds", event))
vail.addEventListener("nosound", event => log("#sounds", event))

vail.addEventListener("clients", event => clients(event))
vail.addEventListener("sound", event => sound(event))
		</script>
	</head>
	<body>
		<h1>Vail API Demo</h1>

		<div><a href="https://vail.woozle.org/#demo" target="_blank">Repeater</a></div>
		<div>Sounder: <span id="sounder"></span></div>
		<div>Clients: <span id="nclients">0</span></div>
		<div id="wpmDisplay">Guessed WPM: 15</div>
		<div id="decodedText">Decoded Message: </div>

		<section id="sounds">
			<h2>sound events</h2>
			<div class="log"></div>
			<p>
				Implementations should use sound events, which will be dispatched
				in the correct order, and only have one duration per event.
			</p>
		</section>

		<section id="clients">
			<h2>clients events</h2>
			<div class="log"></div>
			<p>
				Clients events are dispatched whenever the number of
				connected clients changes.
			</p>
		</section>

		<section id="messages">
			<h2>message events</h2>
			<div class="log"></div>
			<p>
				Message events are "raw" events. They may arrive out of order,
				and can have multiple durations.
				The Vail class parses these into properly-sequenced
				"sound" events.
			</p>
		</section>
	</body>
</html>
